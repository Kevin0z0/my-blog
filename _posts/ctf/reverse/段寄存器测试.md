---
typora-root-url: ..\..\..\
title: '段寄存器测试'
author: Kevin。
tags:
  - reverse
categories:
  - ctf
date: 2022-04-07 13:18:00
img: /images/article-banner/protect.jpg
---

# 寄存器测试

## 内存地址转换过程

虚拟地址 -->段选择子+偏移地址-->分段管理机制-->线性地址-->分页管理机制-->物理地址

![地址映射转换过程](/images/段寄存器测试/image-20220407190335760.png)

## 不同段寄存器对应不同作用

> ES ---> 对串进行操作 [ESI] [EDI] STOSD MOVSD
>
> CS ---> EIP EBP
>
> DS ---> 通用
>
> FS ---> 异常
>
> GS ---> 保留
>
> 系统段 ---> LDTR  TR

段寄存器有96位，但在3环仅可使用16位选择子

```c
struct Segment{
    WORD selector;//3环用户态只能看到选择子
    WORD attributes;//系统
    DWORD base;//系统
    DWORD limit;//系统
}
```

获取不同寄段存器的选择子

```assembly
mov ax, es #0x23
mov cx, cs #0x1b
mov dx, ss #0x23
mov ax, ds #0x23
mov cs, fs #0x3b
mov dx, gs #0x00
ldtr #0x0
tr   #0x28
sldt ax #读取ldtr
lldt    #写ldtr，只有0环可操作
str cx  #读取tr
ltr     #写tr，只有0环可操作
```

## 修改段寄存器

```c
int var;
int main(){
    _asm{
        mov ax, ss;
        mov ds, ax;
        mov var, eax;
    }
}

```

在32位系统中，由于ss和ds的值相同，所以可以运行，若将ss改成cs，则会发生0xc0000005内存冲突

```c
int var;
int main(){
    _asm{
        mov ax, cs;
        mov ds, ax;
        mov var, eax; //此步内存冲突
    }
}
```

因为ds对应数据段，可读可写，而cs对应EIP，EIP对应代码段，代码段可读不可写，所以eax无法给var赋值

如下代码，当段寄存器不为0，偏移为0时，可以访问该地址。若将fs改成ds（ds一般为0），gs:[0] = 0x0，访问报错

```c
int var;
int main(){
    _asm{
        mov ax, fs;
        mov gs, ax;
        mov eax, gs:[0];
        mov var, eax;
    }
}
```

fs的基址为0x7ffdf000，界限为0xfff，超过0xfff会报错

```c
int var;
int main(){
    _asm{
        mov ax, fs;
        mov gs, ax;
        mov eax, gs:[0xffd]; //ffd ffe fff 1000 
        //eax有4个字节，而fs的界限为0xfff，0xffd+4=0x1000超出了0xfff界限，所以报错
        mov var, eax;
    }
}
```



```c
struct GDTR{ //一个CPU只有一份
	WORD LIMIT;
	DOWRD BASE;
} 
```

通用寄存器给段寄存器赋值16位扩展96位