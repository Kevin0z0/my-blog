---
title: 系统段描述符表IDTR
date: 2022-04-14 13:36:56
typora-root-url: ..\..\..\
author: Kevin。
tags:
  - reverse
categories:
  - ctf
img: /images/article-banner/QQ截图20220412194908.jpg
---

# 系统段描述符表IDTR

## 中断门和陷阱门

不同描述符表中的值代表不同类型的门，放在gdtr表里面的门叫做调用门，放在idtr表里面的门叫做中断门和陷阱门

中断门和陷阱门描述中断/异常处理程序的入口点。中断门和陷阱门内的选择子必须指向代码段描述符，门内的偏移就是对应代码段的入口点偏移。中断门和陷阱门只有在终端描述符表IDT中才有效

## 中断

对80386而言，中断是由异步的外部事件引起的，也就是cpu外部中断。在汇编中，可以用`int`指令进入中断门，`int 0x1` 代表调用IDTR指向的第一个门，依次类推，`int 0x20` 就是指向IDTR + 0x20 * 8地址的描述符。读取idt中的8个字节，就获取系统函数入口。

## 异常

异常时80386在执行指令期间检测到不正常的或非法的条件引起的，也就是cpu内部中断。当异常发生后，吃力气就像响应中断那样处理异常。也就是根据中断向量号，跳转到IDT对应的地址。

## WinDBG测试

使用命令`dq idtr l70`在idt中找到一块空地址，计算一个描述符

此处选择0x8003f500地址，根据`(当前地址-基址)/8`可以算出中断偏移量为`0x20`

![查找空的内存地址](/images/image-20220414162525805.png)

根据下表进一步构造中断门这8字符的值，这里取0x60000000为基址，计算出来则为```0x6000ee00`00080000```

![不同TYPE对应的意思](/images/image-20220412171457218.png)

![image-20220414164042163](/images/image-20220414164042163.png)

编写代码

```c
#include "StdAfx.h"
#include <Windows.h>

WORD w_cs;
WORD w_ss;

BYTE GdtBuffer[0x4000];

DWORD GetFunAddress(void* Fun){
	BYTE* p;
	p = (BYTE*)Fun;
	if (*p == 0xe9){
		p = p+5+ *(DWORD*)&p[1];
	}
	return (DWORD)p;
}


_declspec(naked)void fun(){
	_asm {
		push ebp
		mov ebp,esp
		sub esp,0x44
		push ebx
		push esi
		push edi
	}

 	_asm {
 		mov ax,cs
		mov cx,ss
 		mov w_cs,ax
 		mov w_ss,cx
 	}

	BYTE* pGdtAddress;
	int i;

	pGdtAddress = (BYTE*)0x8003f400;

	for (i = 0; i < 0x400; i++ ){
        GdtBuffer[i] = pGdtAddress[i];
	}

	_asm{
		pop edi
		pop esi
		pop ebx
		mov esp,ebp
		pop ebp
		iretd
	}
}

int main(int argc, char* argv[]){
	LPVOID pAddress;
	DWORD dwFunAddress;
    pAddress = VirtualAlloc((void*)0x60000000,0x4000, MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
	
	if ( pAddress != NULL ){
		dwFunAddress = GetFunAddress(fun);
		memcpy(pAddress, (void*)dwFunAddress,0x200);
	}
	memset(GdtBuffer,0x0,0x4000);
	int i;

	_asm{
		int 0x20
	}
	printf("cs = %x  ss = %x\n", w_cs,w_ss);
	for ( i = 0; i < 0x100; i+= 2){
		printf(" 0x%08x`0x%08x\n", *(DWORD*)&GdtBuffer[i*4+4], *(DWORD*)&GdtBuffer[i*4]);
	}
	printf("Hello World!\n");
	return 0;
}
```

成功打印

![打印IDT](/images/image-20220414164401021.png)

IDT中不为空的地址代表系统函数的入口地址

取第一个地址的EIP `u 0x805431a0`，可以看到系统函数名和反汇编

![IDT第一个地址](/images/image-20220414171412720.png)

![IDT第一个地址对应的函数](/images/image-20220414171457528.png)

依次尝试接下来的几个，可以发现均为系统函数的入口

![windbg查看汇编](/images/image-20220414171702438.png)



















